# 미래 세계에는 인간들의 지능이 큰 폭으로 성장하여, TV의 리모콘 조차 많은 버튼이 필요하지 않게 되었습니다.

# 미래 세계의 TV의 리모콘은 다음과 같은 4개의 버튼만이 존재합니다.

#     [/2 버튼]: 현재 채널의 절반의 숫자의 채널로 이동합니다. 만약 홀수라면, /2를 한 몫만큼의 채널로 이동합니다.
#     (예: 4 -> 2, 5 -> 2)
#     [x2 버튼]: 현재 채널의 2배만큼의 숫자의 채널로 이동합니다.
#     (예: 4 -> 8, 5 -> 10)
#     [+1 버튼]: 현재 채널에서 +1만큼의 숫자의 채널로 이동합니다.
#     (예: 4 -> 5, 5 -> 6)
#     [-1 버튼]: 현재 채널에서 -1만큼의 숫자의 채널로 이동합니다.
#     (예: 4 -> 3, 5 -> 4)

# 미래 세계에서의 TV는 공통으로 총 0번부터 100,000번까지의 채널이 존재합니다.

# 이 범위를 벗어나는 채널로는 이동할 수 없습니다.
 
# 예를 들어, 50002번 채널에서 x2 버튼을 누르면, 아무 동작을 하지 않으며, 0번 채널에서 -1 버튼을 눌러도 아무 동작도 하지 않습니다.

# 현재 채널로부터 목표 채널까지 이동하기 위한 최소한의 버튼 제어의 횟수를 알려주는 프로그램을 작성하세요.

# 입력

# 첫번째 줄에 현재 채널 S가 입력됩니다. (0 <= S <= 100,000)

# 두번째 줄에 목표 채널 D가 입력됩니다. (0 <= D <= 100,000, S=/=D)

# 출력

# 첫번째 줄에 S채널로부터 D채널까지 이동하기 위한 최소한의 버튼 제어 횟수를 출력합니다.

from collections import deque

def BFS(start, target):
    visited = [False] * 100001
    queue = deque([(start, 0)])
    visited[start] = True

    while queue:
        cur, level = queue.popleft()
        nxt = [cur // 2, cur * 2, cur + 1, cur - 1]
        if cur == target:
            return level
        
        for k in range(4):
            if 0 <= nxt[k] <= 100000 and not visited[nxt[k]]:
                visited[nxt[k]] = True
                queue.append((nxt[k], level + 1))
    return -1

S = int(input())
D = int(input())

print(BFS(S, D))
